<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã•ã‚“ã™ã†ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚° (1å¹´ç”Ÿãƒ»ã›ã‚“ãŸãã—ã)</title> <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    keyframes: {
                        shake: { '10%, 90%': { transform: 'translateX(-2px)' }, '20%, 80%': { transform: 'translateX(2px)' }, '30%, 50%, 70%': { transform: 'translateX(-4px)' }, '40%, 60%': { transform: 'translateX(4px)' } },
                        pop: { '0%, 100%': { transform: 'scale(1)' }, '50%': { transform: 'scale(1.1)' } }
                    },
                    animation: { shake: 'shake 0.4s ease-in-out', pop: 'pop 0.3s ease-out' }
                }
            }
        }
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=M+PLUS+Rounded+1c:wght@500;700;900&display=swap" rel="stylesheet"> <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        html, body { height: 100%; overflow-x: hidden; }
        body {
            font-family: 'Inter', 'M PLUS Rounded 1c', sans-serif;
            overscroll-behavior-y: contain; display: flex; flex-direction: column;
            align-items: center; justify-content: center; padding: 1rem;
            box-sizing: border-box; background: linear-gradient(135deg, #e0f7fa 0%, #e1f5fe 100%);
        }
        canvas {
            display: block; margin: 0 auto; background-color: #fff;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1); border-radius: 12px;
            cursor: default; max-width: 100%; flex-shrink: 0;
        }
        /* â˜… é¸æŠè‚¢ãƒœã‚¿ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ« â˜… */
        .choice-button {
            min-width: 80px; /* å°‘ã—å°ã•ã */
            padding: 0.8rem 1rem; /* ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°èª¿æ•´ */
            font-size: 1.3rem; /* ãƒ•ã‚©ãƒ³ãƒˆã‚’å¤§ãã */
            font-weight: 700; /* å¤ªå­— */
            border-radius: 0.75rem; /* è§’ä¸¸ã‚’å¤§ãã */
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            background-color: #60a5fa; /* bg-blue-400 */
            color: white;
        }
        .choice-button:hover { background-color: #3b82f6; /* bg-blue-600 */ transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.15); }
        .choice-button:active { transform: translateY(0px); box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .choice-button:disabled { background-color: #9ca3af; /* bg-gray-400 */ cursor: not-allowed; opacity: 0.7; transform: none; box-shadow: 0 2px 4px rgba(0,0,0,0.1);}

        .control-button { min-width: 110px; padding: 0.5rem 0.8rem; font-size: 0.9rem; }
        #controls { width: 100%; max-width: 600px; padding: 0 1rem; box-sizing: border-box; margin-top: 0.75rem; flex-shrink: 0; }
        #num-questions { padding: 0.4rem 0.6rem; font-size: 0.9rem; }
        h1 { font-size: 1.5rem; margin-bottom: 0.5rem; }
        #stats-area { margin-bottom: 0.5rem; min-height: 1.5rem; }
        @media (min-width: 768px) { /* md breakpoint */
            h1 { font-size: 1.875rem; margin-bottom: 1rem; }
            #stats-area { margin-bottom: 0.5rem; }
            .control-button { min-width: 120px; padding: 0.5rem 1rem; font-size: 1rem; }
            #num-questions { padding: 0.25rem 0.75rem; font-size: 1rem; }
            #controls { margin-top: 1rem; }
            .choice-button { min-width: 100px; font-size: 1.5rem; }
        }
        .feedback-pop { animation: pop 0.3s ease-out; display: inline-block; }
    </style>
</head>
<body class="bg-gradient-to-br from-teal-100 to-cyan-200">

    <div class="w-full max-w-2xl text-center flex-shrink-0">
        <h1 class="font-bold text-gray-800">ã•ã‚“ã™ã†ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚° (1å¹´ç”Ÿãƒ»ã›ã‚“ãŸãã—ã)</h1>
         <div id="stats-area" class="text-base sm:text-lg font-semibold text-gray-700 h-6"></div>
    </div>

    <canvas id="mathCanvas"></canvas>
    <div id="choice-box" class="hidden flex flex-wrap justify-center gap-3 sm:gap-4 mt-4">
        </div>

    <div id="controls" class="flex flex-wrap justify-center gap-2 sm:gap-3">
        <div id="settings-controls" class="flex flex-wrap justify-center items-center gap-2 sm:gap-3">
            <label for="num-questions" class="text-gray-700 font-medium text-sm sm:text-base">ã‚‚ã‚“ã ã„ã®ã‹ãš:</label>
            <select id="num-questions" class="rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-teal-400">
                <option value="5">5ã‚‚ã‚“</option> <option value="10" selected>10ã‚‚ã‚“</option> <option value="15">15ã‚‚ã‚“</option> <option value="20">20ã‚‚ã‚“</option>
            </select>
            <button id="start-button" class="control-button bg-teal-500 hover:bg-teal-600 text-white font-bold rounded-lg transition shadow">ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
        </div>
        <div id="training-controls" class="hidden flex flex-wrap justify-center gap-2 sm:gap-3">
             <button id="next-button" class="control-button bg-green-500 hover:bg-green-600 text-white font-bold rounded-lg transition shadow hidden">ã¤ãã®ã‚‚ã‚“ã ã„</button>
        </div>
        <div id="end-controls" class="hidden flex flex-wrap justify-center gap-2 sm:gap-3">
            <button id="restart-button" class="control-button bg-purple-500 hover:bg-purple-600 text-white font-bold rounded-lg transition shadow">ã‚‚ã†ã„ã£ã‹ã„</button>
            <button id="review-button" class="control-button bg-orange-500 hover:bg-orange-600 text-white font-bold rounded-lg transition shadow">ã¾ã¡ãŒã„ã‹ãã«ã‚“</button>
         </div>
         <div id="review-controls" class="hidden flex flex-wrap justify-center gap-2 sm:gap-3">
             <button id="back-to-start-button" class="control-button bg-gray-500 hover:bg-gray-600 text-white font-bold rounded-lg transition shadow">ã•ã„ã—ã‚‡ã«ã‚‚ã©ã‚‹</button>
         </div>
    </div>

    <script>
        // --- ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ãƒ»å®šæ•° ---
        const canvas = document.getElementById('mathCanvas');
        const ctx = canvas.getContext('2d');
        // const hiddenInput = document.getElementById('hidden-input'); // â˜…å‰Šé™¤
        const statsArea = document.getElementById('stats-area');
        const choiceBox = document.getElementById('choice-box'); // â˜…é¸æŠè‚¢ã‚³ãƒ³ãƒ†ãƒŠå–å¾—

        // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«è¦ç´ 
        const settingsControls = document.getElementById('settings-controls');
        const trainingControls = document.getElementById('training-controls');
        const endControls = document.getElementById('end-controls');
        const reviewControls = document.getElementById('review-controls');
        const numQuestionsSelect = document.getElementById('num-questions');
        const startButton = document.getElementById('start-button');
        // const submitButton = document.getElementById('submit-button'); // â˜…å‰Šé™¤
        const nextButton = document.getElementById('next-button');
        const restartButton = document.getElementById('restart-button');
        const reviewButton = document.getElementById('review-button');
        const backToStartButton = document.getElementById('back-to-start-button');

        // ã‚²ãƒ¼ãƒ ã®çŠ¶æ…‹å¤‰æ•°
        let gameState = 'settings';
        let currentQuestionIndex = 0; let score = 0; let totalQuestions = 10;
        let questions = []; let attemptedQuestions = [];
        // let currentAnswer = ''; // â˜…ä¸è¦
        let feedback = { message: '', color: 'black', effect: null };
        let mistakes = []; let reviewScrollOffset = 0; let currentStreak = 0;

        // åŠ¹æœéŸ³é–¢é€£ (å¤‰æ›´ãªã—)
        let synth; let isAudioContextStarted = false;

        // ãŠç¥ã„æ¼”å‡ºé–¢é€£ (å¤‰æ›´ãªã—)
        let confettiParticles = []; let isCelebrating = false; let celebrationPlayed = false;

        // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼é–¢é€£ (å¤‰æ›´ãªã—)
        let characterState = 'idle';
        const BASE_CHARACTER_X = 50; const BASE_CHARACTER_Y = 350; const BASE_CHARACTER_RADIUS = 25;

        // --- ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ --- (å¤‰æ›´ãªã—)
        const BASE_CANVAS_WIDTH = 600; const BASE_CANVAS_HEIGHT = 400; let scale = 1;

        // Canvasæç”»é–¢é€£ã®åŸºæº–å®šæ•° (å¤‰æ›´ãªã—)
        const BASE_PROGRESS_Y = 55; const BASE_QUESTION_Y = 130; const BASE_INPUT_BOX_Y = 190;
        const BASE_INPUT_BOX_HEIGHT = 40; const BASE_FEEDBACK_Y = 290; // ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ä½ç½®å°‘ã—ä¸Šã’ã‚‹
        const BASE_FONT_SIZE_XL = 32; const BASE_FONT_SIZE_L = 28; const BASE_FONT_SIZE_M = 24;
        const BASE_FONT_SIZE_S = 20; const BASE_FONT_SIZE_XS = 18; const BASE_FONT_SIZE_XXS = 16;
        const BASE_FONT_SIZE_TINY = 14;


        // --- è¨ˆç®—é–¢é€£ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•° ---
        function getRandomInt(min, max) { min = Math.ceil(min); max = Math.floor(max); return Math.floor(Math.random() * (max - min + 1)) + min; } // (å¤‰æ›´ãªã—)

        // â˜… parseAnswerInput ã¯ä¸è¦ã«ãªã£ãŸã®ã§å‰Šé™¤ â˜…

        /** è§£ç­”(æ•°å€¤)ã‚’æ–‡å­—åˆ—ã«å¤‰æ› */
        function formatAnswer(answer) { if (typeof answer === 'number') { return answer.toString(); } return ''; } // (å¤‰æ›´ãªã—)

        // --- å•é¡Œç”Ÿæˆé–¢æ•° (å°å­¦1å¹´ç”Ÿãƒ¬ãƒ™ãƒ«ã«å¤‰æ›´æ¸ˆã¿) ---
        function generateGrade1Addition() { const n1 = getRandomInt(0, 10); const n2 = getRandomInt(0, 10); const answer = n1 + n2; const question = `${n1} + ${n2} = ?`; return { question, answer, type: 'integer' }; } // (å¤‰æ›´ãªã—)
        function generateGrade1Subtraction() { const n1 = getRandomInt(1, 20); const n2 = getRandomInt(0, n1); const answer = n1 - n2; const question = `${n1} - ${n2} = ?`; return { question, answer, type: 'integer' }; } // (å¤‰æ›´ãªã—)
        function generateQuestions(numQs) { questions = []; const questionTypes = [ generateGrade1Addition, generateGrade1Subtraction ]; for (let i = 0; i < numQs; i++) { const randomTypeIndex = Math.floor(Math.random() * questionTypes.length); try { questions.push(questionTypes[randomTypeIndex]()); } catch (error) { console.error("Error generating question:", error); i--; } } } // (å¤‰æ›´ãªã—)

        // --- é¸æŠè‚¢é–¢é€£ ---

        /**
         * â˜… é…åˆ—ã‚’ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã™ã‚‹é–¢æ•° (Fisher-Yates) â˜…
         * @param {Array} array - ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã—ãŸã„é…åˆ—
         * @returns {Array} ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã•ã‚ŒãŸé…åˆ— (å…ƒã®é…åˆ—ã¯å¤‰æ›´ã—ãªã„)
         */
        function shuffleArray(array) {
            const shuffled = [...array]; // é…åˆ—ã‚’ã‚³ãƒ”ãƒ¼
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]]; // è¦ç´ ã‚’äº¤æ›
            }
            return shuffled;
        }

        /**
         * â˜… é¸æŠè‚¢ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤ºã™ã‚‹é–¢æ•° â˜…
         * @param {number} correctAnswer - æ­£ã—ã„ç­”ãˆ
         */
        function displayChoices(correctAnswer) {
            choiceBox.innerHTML = ''; // æ—¢å­˜ã®é¸æŠè‚¢ã‚’ã‚¯ãƒªã‚¢
            choiceBox.classList.remove('hidden'); // è¡¨ç¤ºã™ã‚‹

            // ãƒ€ãƒŸãƒ¼ã®é¸æŠè‚¢ã‚’ç”Ÿæˆ
            let choices = [correctAnswer];
            let attempts = 0; // ç„¡é™ãƒ«ãƒ¼ãƒ—é˜²æ­¢
            while (choices.length < 3 && attempts < 10) {
                let dummyAnswer;
                // æ­£è§£ã«è¿‘ã„ãŒç•°ãªã‚‹å€¤ã‚’ç”Ÿæˆ
                const plusMinus = Math.random() < 0.5 ? -1 : 1;
                const diff = getRandomInt(1, 3); // 1ã€œ3é•ã„
                dummyAnswer = correctAnswer + (plusMinus * diff);

                // 0æœªæº€ã«ãªã‚‰ãšã€ã‹ã¤ä»–ã®é¸æŠè‚¢ã¨é‡è¤‡ã—ãªã„ã‚ˆã†ã«ã™ã‚‹
                if (dummyAnswer >= 0 && !choices.includes(dummyAnswer)) {
                    choices.push(dummyAnswer);
                }
                attempts++;
            }
             // ã‚‚ã—ä¸Šè¨˜ã§3ã¤ç”Ÿæˆã§ããªã‹ã£ãŸå ´åˆï¼ˆä¾‹: æ­£è§£ãŒ0ã‚„1ã®å ´åˆï¼‰ã€å˜ç´”ãª+1,+2ã‚’è¿½åŠ 
             while (choices.length < 3) {
                 let dummyAnswer = choices[choices.length - 1] + 1; // æœ€å¾Œã®è¦ç´ +1
                 if (!choices.includes(dummyAnswer)) {
                     choices.push(dummyAnswer);
                 } else { // ãã‚Œã§ã‚‚é‡è¤‡ã—ãŸã‚‰+2
                     dummyAnswer++;
                     if (!choices.includes(dummyAnswer)) choices.push(dummyAnswer);
                     else break; // ã©ã†ã—ã¦ã‚‚ç„¡ç†ãªã‚‰è«¦ã‚ã‚‹
                 }
             }


            const shuffledChoices = shuffleArray(choices);

            shuffledChoices.forEach(choice => {
                const button = document.createElement('button');
                button.textContent = choice;
                button.classList.add('choice-button'); // æ–°ã—ã„ã‚¹ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹
                button.dataset.value = choice; // ãƒœã‚¿ãƒ³ã«å€¤ã‚’ä¿æŒ
                button.addEventListener('click', handleChoiceClick);
                choiceBox.appendChild(button);
            });
        }

        /**
         * â˜… é¸æŠè‚¢ãƒœã‚¿ãƒ³ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸã¨ãã®ãƒãƒ³ãƒ‰ãƒ© â˜…
         * @param {Event} event - ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
         */
        function handleChoiceClick(event) {
            if (gameState !== 'training') return; // ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ä¸­ã®ã¿æœ‰åŠ¹

            const selectedValue = parseInt(event.target.dataset.value, 10);
            checkAnswer(selectedValue); // é¸æŠã•ã‚ŒãŸå€¤ã§ç­”ãˆåˆã‚ã›

            // ã™ã¹ã¦ã®é¸æŠè‚¢ãƒœã‚¿ãƒ³ã‚’ç„¡åŠ¹åŒ–
            const buttons = choiceBox.querySelectorAll('button');
            buttons.forEach(button => button.disabled = true);
        }


        // --- Canvasæç”»é–¢é€£é–¢æ•° ---

        /** Canvasã‚’ã‚¯ãƒªã‚¢ */
        function clearCanvas() { ctx.clearRect(0, 0, canvas.width, canvas.height); }

        /** ãƒ†ã‚­ã‚¹ãƒˆã‚’æç”» (ã‚¹ã‚±ãƒ¼ãƒ«å¯¾å¿œ) */
        function drawText(text, x, y, font = ``, color = 'black', align = 'center', baseline = 'alphabetic') { ctx.font = font; ctx.fillStyle = color; ctx.textAlign = align; ctx.textBaseline = baseline; ctx.fillText(text, x, y); }

        /** ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ã‚’æç”» (ã‚¹ã‚±ãƒ¼ãƒ«å¯¾å¿œ) */
        function drawProgressBar() { // (å¤‰æ›´ãªã—)
            const barWidth = canvas.width * 0.6; const barHeight = 10 * scale; const barX = (canvas.width - barWidth) / 2;
            const progress = totalQuestions > 0 ? (currentQuestionIndex + (gameState === 'feedback' || gameState === 'finished' ? 1 : 0)) / totalQuestions : 0;
            const scaledProgressY = BASE_PROGRESS_Y * scale;
            ctx.fillStyle = '#e0e0e0'; ctx.fillRect(barX, scaledProgressY, barWidth, barHeight);
            ctx.fillStyle = '#4ade80'; ctx.fillRect(barX, scaledProgressY, barWidth * progress, barHeight);
             if (totalQuestions > 0 && gameState !== 'settings' && gameState !== 'finished' && gameState !== 'review') {
                  const scaledFontSize = Math.round(BASE_FONT_SIZE_TINY * scale);
                  drawText(`${currentQuestionIndex + 1} / ${totalQuestions} ã‚‚ã‚“ã‚`, canvas.width / 2, scaledProgressY + (25 * scale), `${scaledFontSize}px Inter`, 'grey', 'center', 'middle');
             }
        }

        /** è¨­å®šç”»é¢ã‚’æç”» (ã‚¹ã‚±ãƒ¼ãƒ«å¯¾å¿œ) */
        function drawSettingsScreen() { // (å¤‰æ›´ãªã—)
            const scaledFontSizeXL = Math.round(BASE_FONT_SIZE_XL * scale); const scaledFontSizeXS = Math.round(BASE_FONT_SIZE_XS * scale);
            drawText('ã›ã£ã¦ã„', canvas.width / 2, 150 * scale, `${scaledFontSizeXL}px "M PLUS Rounded 1c"`, 'black');
            drawText('ã‚‚ã‚“ã ã„ã®ã‹ãšã‚’ ãˆã‚‰ã‚“ã§ ã‚¹ã‚¿ãƒ¼ãƒˆã—ã¦ã­', canvas.width / 2, 200 * scale, `${scaledFontSizeXS}px Inter`, 'grey');
        }

        /** ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ç”»é¢ã‚’æç”» (ã‚¹ã‚±ãƒ¼ãƒ«å¯¾å¿œ) - â˜…å…¥åŠ›æ¬„å‰Šé™¤â˜… */
        function drawTrainingScreen() {
            drawProgressBar(); const currentQ = questions[currentQuestionIndex]; if (!currentQ) return;
            const scaledQuestionY = BASE_QUESTION_Y * scale; const scaledFontSizeL = Math.round(BASE_FONT_SIZE_L * scale);
            // å•é¡Œæ–‡ã‚’å°‘ã—ä¸Šã«è¡¨ç¤º
            drawText(currentQ.question, canvas.width / 2, scaledQuestionY - (20 * scale), `bold ${scaledFontSizeL * 1.1}px "M PLUS Rounded 1c"`, '#333'); // å°‘ã—å¤§ãã

            // â˜… å…¥åŠ›ãƒœãƒƒã‚¯ã‚¹ã€ãƒ’ãƒ³ãƒˆã€ã‚«ãƒ¼ã‚½ãƒ«ã®æç”»ã‚’å‰Šé™¤ â˜…

            drawCharacter(); // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼æç”»
        }

        /** ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ç”»é¢ã‚’æç”» (ã‚¹ã‚±ãƒ¼ãƒ«å¯¾å¿œ) */
        function drawFeedbackScreen() {
            drawTrainingScreen(); // å•é¡Œã¨ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã¯è¡¨ç¤ºã—ãŸã¾ã¾
            const scaledFeedbackY = BASE_FEEDBACK_Y * scale; // ä½ç½®èª¿æ•´
            const scaledFontSizeS = Math.round(BASE_FONT_SIZE_S * scale);
            let message = feedback.message; if (currentStreak >= 3) { message += ` (${currentStreak}ã‚Œã‚“ãã ã›ã„ã‹ã„!)`; }
            drawText(message, canvas.width / 2, scaledFeedbackY, `bold ${scaledFontSizeS}px Inter`, feedback.color);
        }

        /** ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼æç”» */
        function drawCharacter() { // (å¤‰æ›´ãªã—)
            const x = BASE_CHARACTER_X * scale; const y = BASE_CHARACTER_Y * scale; const r = BASE_CHARACTER_RADIUS * scale;
            ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fillStyle = '#ffeb3b'; ctx.fill();
            ctx.strokeStyle = '#fbc02d'; ctx.lineWidth = 2 * scale; ctx.stroke();
            const eyeRX = r * 0.3; const eyeRY = r * 0.4; const eyeY = y - r * 0.15; ctx.fillStyle = 'black';
            ctx.beginPath(); ctx.ellipse(x - r * 0.3, eyeY, eyeRX, eyeRY, 0, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(x + r * 0.3, eyeY, eyeRX, eyeRY, 0, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.lineWidth = 2 * scale; ctx.strokeStyle = 'black'; const mouthY = y + r * 0.3; const mouthWidth = r * 0.6;
            if (characterState === 'happy') { ctx.arc(x, mouthY - r * 0.1, mouthWidth / 2, 0, Math.PI, false); }
            else if (characterState === 'sad') { ctx.arc(x, mouthY + r * 0.2, mouthWidth / 2, Math.PI, Math.PI * 2, false); }
            else { ctx.moveTo(x - mouthWidth / 2, mouthY); ctx.lineTo(x + mouthWidth / 2, mouthY); }
            ctx.stroke();
        }

        // --- ãŠç¥ã„æ¼”å‡ºï¼ˆç´™å¹é›ªï¼‰é–¢é€£ (å¤‰æ›´ãªã—) ---
        const confettiColors = ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4caf50', '#8bc34a', '#cddc39', '#ffeb3b', '#ffc107', '#ff9800', '#ff5722'];
        function createConfetti() { confettiParticles = []; const numberOfParticles = 100; for (let i = 0; i < numberOfParticles; i++) { confettiParticles.push({ x: Math.random() * canvas.width, y: -Math.random() * canvas.height * 0.5, size: (Math.random() * 5 + 3) * scale, color: confettiColors[Math.floor(Math.random() * confettiColors.length)], speedX: (Math.random() * 6 - 3) * scale, speedY: (Math.random() * 3 + 2) * scale, angle: Math.random() * Math.PI * 2, angularSpeed: Math.random() * 0.1 - 0.05 }); } }
        function updateConfetti() { const gravity = 0.1 * scale; confettiParticles.forEach((p) => { p.speedY += gravity; p.x += p.speedX; p.y += p.speedY; p.angle += p.angularSpeed; }); confettiParticles = confettiParticles.filter(p => p.y <= canvas.height + p.size * 5); if (confettiParticles.length === 0) { isCelebrating = false; } }
        function drawConfetti() { confettiParticles.forEach(p => { ctx.save(); ctx.fillStyle = p.color; ctx.translate(p.x + p.size / 2, p.y + p.size / 2); ctx.rotate(p.angle); ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size); ctx.restore(); }); }
        // --- ç´™å¹é›ªã“ã“ã¾ã§ ---

         /** çµ‚äº†ç”»é¢ã‚’æç”» (ã‚¹ã‚±ãƒ¼ãƒ«å¯¾å¿œ) */
        function drawFinishedScreen() { // (å¤‰æ›´ãªã—)
            const finalScoreText = `ãŠã‚ã‚Šï¼ ${totalQuestions}ã‚‚ã‚“ ã¡ã‚…ã† ${score}ã‚‚ã‚“ ã›ã„ã‹ã„ï¼`; const accuracy = totalQuestions > 0 ? ((score / totalQuestions) * 100) : 0; const accuracyText = `ã›ã„ã‹ã„ã‚Šã¤: ${accuracy.toFixed(1)}%`;
            if (accuracy >= 80 && !celebrationPlayed) {
                isCelebrating = true; celebrationPlayed = true; createConfetti();
                if (synth && isAudioContextStarted) { try { synth.triggerAttackRelease("C5", "8n", Tone.now()); synth.triggerAttackRelease("E5", "8n", Tone.now() + 0.15); synth.triggerAttackRelease("G5", "8n", Tone.now() + 0.3); synth.triggerAttackRelease("C6", "4n", Tone.now() + 0.45); } catch(e) { console.error("Error playing celebration sound:", e); } }
            }
            if (isCelebrating) { updateConfetti(); drawConfetti(); }
            const scaledFontSizeXL = Math.round(BASE_FONT_SIZE_XL * scale); const scaledFontSizeM = Math.round(BASE_FONT_SIZE_M * scale); const scaledFontSizeXXS = Math.round(BASE_FONT_SIZE_XXS * scale); const scaledFontSizeXS = Math.round(BASE_FONT_SIZE_XS * scale);
            drawText('ãŠã¤ã‹ã‚Œã•ã¾ï¼', canvas.width / 2, 120 * scale, `${scaledFontSizeXL}px "M PLUS Rounded 1c"`, 'black');
            drawText(finalScoreText, canvas.width / 2, 180 * scale, `${scaledFontSizeM}px Inter`, '#4a5568');
            drawText(accuracyText, canvas.width / 2, 220 * scale, `${scaledFontSizeM}px Inter`, '#4a5568');
            if (mistakes.length > 0) { drawText(`(${mistakes.length}ã‚‚ã‚“ ã¾ã¡ãŒãˆãŸã­)`, canvas.width / 2, 260 * scale, `${scaledFontSizeXXS}px Inter`, 'grey'); }
            else { drawText('ãœã‚“ã¶ ã›ã„ã‹ã„ï¼ã™ã”ã„ï¼ ğŸ‰', canvas.width / 2, 260 * scale, `${scaledFontSizeXS}px Inter`, 'green');
                 if (!celebrationPlayed) { isCelebrating = true; celebrationPlayed = true; createConfetti(); if (synth && isAudioContextStarted) { try { synth.triggerAttackRelease("C5", "8n", Tone.now()); synth.triggerAttackRelease("E5", "8n", Tone.now() + 0.15); synth.triggerAttackRelease("G5", "8n", Tone.now() + 0.3); synth.triggerAttackRelease("C6", "4n", Tone.now() + 0.45); } catch(e) { console.error("Error playing sound:", e); } } }
            }
            if (isCelebrating) { requestAnimationFrame(draw); }
        }

        /** ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”»é¢ã‚’æç”» (ã‚¹ã‚±ãƒ¼ãƒ«å¯¾å¿œ) */
        function drawReviewScreen() { // (å¤‰æ›´ãªã—)
            const scaledFontSizeM = Math.round(BASE_FONT_SIZE_M * scale); const scaledFontSizeXS = Math.round(BASE_FONT_SIZE_XS * scale); const scaledFontSizeXXS = Math.round(BASE_FONT_SIZE_XXS * scale);
            drawText('ã¾ã¡ãŒã„ã®ã‹ãã«ã‚“', canvas.width / 2, 40 * scale, `${scaledFontSizeM}px "M PLUS Rounded 1c"`, 'black');
            if (mistakes.length === 0) { drawText('ã¾ã¡ãŒãˆãŸ ã‚‚ã‚“ã ã„ã¯ ãªã‹ã£ãŸã‚ˆ', canvas.width / 2, 150 * scale, `${scaledFontSizeXS}px Inter`, 'green'); return; }
            const itemHeight = 85 * scale; const startY = 80 * scale; const contentWidth = canvas.width * 0.9; const startX = (canvas.width - contentWidth) / 2; const reviewAreaTop = startY - (10 * scale); const reviewAreaHeight = canvas.height - startY - (20 * scale);
             ctx.save(); ctx.beginPath(); ctx.rect(0, reviewAreaTop, canvas.width, reviewAreaHeight); ctx.clip();
             const drawStartY = startY - reviewScrollOffset;
            mistakes.forEach((mistake, index) => {
                const yPos = drawStartY + index * itemHeight; if (yPos + itemHeight < reviewAreaTop || yPos > reviewAreaTop + reviewAreaHeight) { return; }
                ctx.fillStyle = index % 2 === 0 ? '#f7fafc' : '#edf2f7'; ctx.fillRect(startX, yPos, contentWidth, itemHeight - (5 * scale));
                const textY1 = yPos + (20 * scale); const textY2 = yPos + (45 * scale); const textY3 = yPos + (70 * scale);
                // â˜… ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”»é¢ã®ãƒ†ã‚­ã‚¹ãƒˆã‚‚æ•´æ•°ã®ã¿ã« â˜…
                drawText(`ã‚‚ã‚“ã ã„ ${mistake.index + 1}: ${mistake.questionObj.question}`, startX + (10 * scale), textY1, `${scaledFontSizeXXS}px "M PLUS Rounded 1c"`, '#2d3748', 'left');
                drawText(`ãã¿ã® ã“ãŸãˆ: ${mistake.userAnswerRaw}`, startX + (15 * scale), textY2, `${scaledFontSizeXXS}px Inter`, '#e53e3e', 'left'); // Raw input is still relevant
                drawText(`ãŸã ã—ã„ ã“ãŸãˆ: ${formatAnswer(mistake.correctAnswer)}`, startX + (15 * scale), textY3, `${scaledFontSizeXXS}px Inter`, '#38a169', 'left');
            });
            ctx.restore();
            const totalContentHeight = mistakes.length * itemHeight; const visibleHeight = reviewAreaHeight;
            if (totalContentHeight > visibleHeight) {
                const scrollBarHeight = Math.max(20 * scale, visibleHeight * (visibleHeight / totalContentHeight)); const scrollRatio = reviewScrollOffset / (totalContentHeight - visibleHeight);
                 const clampedScrollRatio = Math.max(0, Math.min(1, scrollRatio)); const scrollBarY = reviewAreaTop + clampedScrollRatio * (visibleHeight - scrollBarHeight); const scrollBarX = canvas.width - (15 * scale);
                 ctx.fillStyle = '#a0aec0'; ctx.fillRect(scrollBarX, scrollBarY, 8 * scale, scrollBarHeight);
            }
        }

        /** ãƒ¡ã‚¤ãƒ³ã®æç”»é–¢æ•° */
        function draw() { // (å¤‰æ›´ãªã—)
            clearCanvas(); updateStatsDisplay();
            switch (gameState) {
                case 'settings': drawSettingsScreen(); break; case 'training': drawTrainingScreen(); break;
                case 'feedback': drawFeedbackScreen(); break; case 'finished': drawFinishedScreen(); break;
                case 'review': drawReviewScreen(); break;
            }
             // â˜… hiddenInput ãŒãªã„ã®ã§æ¡ä»¶å¤‰æ›´ â˜…
             if (gameState === 'training' || isCelebrating) { requestAnimationFrame(draw); }
        }

        // --- ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯é–¢é€£é–¢æ•° ---

        /** çµ±è¨ˆæƒ…å ±è¡¨ç¤ºã‚’æ›´æ–° */
        function updateStatsDisplay() { // (å¤‰æ›´ãªã—)
             const attemptedCount = attemptedQuestions.length; const correctCount = attemptedQuestions.filter(q => q.isCorrect).length;
             const accuracy = attemptedCount > 0 ? ((correctCount / attemptedCount) * 100).toFixed(1) : '---';
             statsArea.textContent = `ã›ã„ã‹ã„ã‚Šã¤: ${accuracy}% (${correctCount}/${attemptedCount}ã‚‚ã‚“)`;
        }

        /** æ“ä½œãƒœã‚¿ãƒ³ã®è¡¨ç¤ºåˆ‡æ›¿ */
        function switchControls(state) {
             settingsControls.classList.add('hidden'); trainingControls.classList.add('hidden'); endControls.classList.add('hidden'); reviewControls.classList.add('hidden');
             choiceBox.classList.add('hidden'); // â˜… é¸æŠè‚¢ã‚‚éš ã™

             switch(state) {
                 case 'settings': settingsControls.classList.remove('hidden'); break;
                 case 'training':
                     trainingControls.classList.remove('hidden');
                     // submitButton is removed
                     nextButton.classList.add('hidden'); // Next button hidden initially
                     choiceBox.classList.remove('hidden'); // â˜… é¸æŠè‚¢è¡¨ç¤º
                     break;
                 case 'feedback':
                     trainingControls.classList.remove('hidden');
                     // submitButton is removed
                     nextButton.classList.remove('hidden'); // Show next button after feedback
                     choiceBox.classList.remove('hidden'); // Keep choices visible but disabled
                     break;
                 case 'finished': endControls.classList.remove('hidden'); break;
                 case 'review': reviewControls.classList.remove('hidden'); break;
             }
        }

        /** ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’é–‹å§‹ */
        async function startAudioContext() { // (å¤‰æ›´ãªã—)
            if (!isAudioContextStarted && Tone.context.state !== 'running') {
                try { await Tone.start(); console.log('Audio context started successfully.'); isAudioContextStarted = true; if (!synth) { synth = new Tone.Synth().toDestination(); } }
                catch (e) { console.error("Could not start audio context:", e); isAudioContextStarted = false; }
            }
             if (isAudioContextStarted && !synth) { synth = new Tone.Synth().toDestination(); }
        }

        /** ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã‚’é–‹å§‹ */
        async function startTraining() {
            await startAudioContext(); totalQuestions = parseInt(numQuestionsSelect.value, 10);
            currentQuestionIndex = 0; score = 0; attemptedQuestions = []; mistakes = []; reviewScrollOffset = 0;
            isCelebrating = false; celebrationPlayed = false; confettiParticles = []; currentStreak = 0; characterState = 'idle';
            generateQuestions(totalQuestions); gameState = 'training';
            // currentAnswer = ''; hiddenInput.value = ''; // â˜…å‰Šé™¤
            switchControls('training');
            // hiddenInput.focus(); // â˜…å‰Šé™¤
            loadQuestion(); // â˜… loadQuestion ã‚’å‘¼ã¶ã‚ˆã†ã«å¤‰æ›´
            // draw(); requestAnimationFrame(draw); // drawã¯loadQuestionå†…ã§å‘¼ã°ã‚Œã‚‹
        }

        /**
         * â˜… å•é¡Œã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¦è¡¨ç¤ºã™ã‚‹é–¢æ•° (é¸æŠè‚¢è¡¨ç¤ºã‚‚å«ã‚€) â˜…
         */
        function loadQuestion() {
             if (currentQuestionIndex < totalQuestions) {
                 const currentQ = questions[currentQuestionIndex];
                 feedback = { message: '', color: 'black', effect: null }; // Reset feedback
                 characterState = 'idle'; // Reset character
                 canvas.classList.remove('animate-shake'); // Reset shake

                 displayChoices(currentQ.answer); // â˜… é¸æŠè‚¢ã‚’è¡¨ç¤º

                 draw(); // Canvasã‚’å†æç”»
                 requestAnimationFrame(draw); // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—é–‹å§‹/ç¶™ç¶š
             } else {
                 gameState = 'finished';
                 switchControls('finished');
                 draw();
             }
        }


        /**
         * â˜… ç­”ãˆã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹é–¢æ•° (é¸æŠã•ã‚ŒãŸå€¤ã‚’å—ã‘å–ã‚‹) â˜…
         * @param {number} selectedValue - ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒé¸æŠã—ãŸç­”ãˆ
         */
        function checkAnswer(selectedValue) {
            // gameState check is done in handleChoiceClick

            // â˜… å…¥åŠ›å€¤ã®èª­ã¿å–ã‚Šã¯ä¸è¦ â˜…
            const currentQ = questions[currentQuestionIndex]; const correctAnswer = currentQ.answer;
            let isCorrect = false; const correctAnswerStr = formatAnswer(correctAnswer);
            feedback.effect = null; canvas.classList.remove('animate-shake');

            // â˜… æ•´æ•°åŒå£«ã®æ¯”è¼ƒã®ã¿ â˜…
            isCorrect = (selectedValue === correctAnswer);

            if (isCorrect) {
                score++; currentStreak++; feedback = { message: 'ã›ã„ã‹ã„ï¼ ğŸ‰', color: 'green', effect: 'pop' };
                characterState = 'happy';
                if (synth && isAudioContextStarted) { try { synth.triggerAttackRelease("C5", "8n", Tone.now()); } catch(e) { console.error("Error playing sound:", e); } }
                if (currentStreak >= 3 && synth && isAudioContextStarted) { try { synth.triggerAttackRelease("E5", "16n", Tone.now() + 0.1); synth.triggerAttackRelease("G5", "16n", Tone.now() + 0.2); } catch(e) { console.error("Error playing streak sound:", e); } }
            } else {
                currentStreak = 0; feedback = { message: `ã–ã‚“ã­ã‚“ï¼ ã“ãŸãˆã¯ ${correctAnswerStr} ã ã‚ˆ`, color: 'red', effect: 'shake' };
                characterState = 'sad';
                if (synth && isAudioContextStarted) { try { synth.triggerAttackRelease("A3", "8n", Tone.now()); } catch(e) { console.error("Error playing sound:", e); } }
            }

            // â˜… userAnswerRaw ã¯é¸æŠã•ã‚ŒãŸå€¤ã«ã™ã‚‹ â˜…
            attemptedQuestions.push({ index: currentQuestionIndex, questionObj: currentQ, userAnswerRaw: selectedValue.toString(), userAnswerParsed: selectedValue, correctAnswer: correctAnswer, isCorrect: isCorrect });
            if (!isCorrect) { mistakes.push(attemptedQuestions[attemptedQuestions.length - 1]); }

            gameState = 'feedback';
            switchControls('feedback'); // Nextãƒœã‚¿ãƒ³è¡¨ç¤º

             if (feedback.effect === 'shake') { canvas.classList.add('animate-shake'); setTimeout(() => canvas.classList.remove('animate-shake'), 400); }

            draw(); // ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯è¡¨ç¤º
        }

        /** æ¬¡ã®å•é¡Œã¸ */
        function nextQuestion() {
            if (gameState !== 'feedback') return;
            currentQuestionIndex++;
            characterState = 'idle'; feedback.effect = null; canvas.classList.remove('animate-shake');
            choiceBox.classList.add('hidden'); // â˜… é¸æŠè‚¢ã‚’éš ã™

            if (currentQuestionIndex < totalQuestions) {
                gameState = 'training';
                switchControls('training');
                loadQuestion(); // â˜… æ¬¡ã®å•é¡Œã‚’ãƒ­ãƒ¼ãƒ‰
            } else {
                gameState = 'finished';
                switchControls('finished');
                draw(); // çµ‚äº†ç”»é¢è¡¨ç¤º
            }
        }

         /** ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ */
         function restartTraining() { // (å¤‰æ›´ãªã—)
             isCelebrating = false; celebrationPlayed = false; confettiParticles = []; currentStreak = 0; characterState = 'idle';
             gameState = 'settings'; feedback = { message: '', color: 'black', effect: null }; statsArea.textContent = '';
             switchControls('settings'); resizeCanvas();
         }

         /** ãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤º */
         function showReview() { // (å¤‰æ›´ãªã—)
             if (gameState !== 'finished') return; isCelebrating = false; characterState = 'idle';
             gameState = 'review'; reviewScrollOffset = 0; switchControls('review'); draw();
         }

         /** è¨­å®šç”»é¢ã¸æˆ»ã‚‹ */
         function backToStart() { // (å¤‰æ›´ãªã—)
             if (gameState !== 'review') return; restartTraining();
         }

         /** Canvasã‚µã‚¤ã‚ºèª¿æ•´é–¢æ•° */
         function resizeCanvas() { // (å¤‰æ›´ãªã—)
             const maxWidth = 700; const availableWidth = window.innerWidth * 0.95;
             const newWidth = Math.min(availableWidth, maxWidth); const newHeight = newWidth * (BASE_CANVAS_HEIGHT / BASE_CANVAS_WIDTH);
             canvas.width = newWidth; canvas.height = newHeight; scale = canvas.width / BASE_CANVAS_WIDTH;
             draw(); if (isCelebrating) { requestAnimationFrame(draw); }
         }


        // --- ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š ---
        startButton.addEventListener('click', async () => { await startTraining(); });
        // submitButton listener removed
        nextButton.addEventListener('click', nextQuestion);
        restartButton.addEventListener('click', restartTraining);
        reviewButton.addEventListener('click', showReview);
        backToStartButton.addEventListener('click', backToStart);

        // â˜… hiddenInput listeners removed â˜…

        // Canvas click listener (for starting audio context mainly)
        canvas.addEventListener('click', async (e) => { await startAudioContext(); });

        // Review screen scroll listener (å¤‰æ›´ãªã—)
        canvas.addEventListener('wheel', (e) => { if (gameState === 'review' && mistakes.length > 0) { e.preventDefault(); const itemHeight = 85 * scale; const totalContentHeight = mistakes.length * itemHeight; const visibleHeight = canvas.height - (80 * scale) - (20 * scale); if (totalContentHeight > visibleHeight) { reviewScrollOffset += e.deltaY * 0.5; reviewScrollOffset = Math.max(0, reviewScrollOffset); reviewScrollOffset = Math.min(reviewScrollOffset, totalContentHeight - visibleHeight + (20 * scale)); draw(); } } }, { passive: false });

        // Window resize listener (å¤‰æ›´ãªã—)
        window.addEventListener('resize', resizeCanvas);


        // --- ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ– ---
        function init() { // (å¤‰æ›´ãªã—)
            gameState = 'settings'; switchControls('settings');
            if (!synth) { try { synth = new Tone.Synth().toDestination(); } catch(e) { console.error("Failed to initialize synth on load:", e); } }
            resizeCanvas();
        }

        // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
        init();

    </script>

</body>
</html>