<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç®—æ•°ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚° Canvasç‰ˆ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=M+PLUS+Rounded+1c:wght@500;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        /* åŸºæœ¬çš„ãªã‚¹ã‚¿ã‚¤ãƒ« */
        body {
            font-family: 'Inter', 'M PLUS Rounded 1c', sans-serif;
            /* ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³ã§ã®ãƒ—ãƒ«ãƒ€ã‚¦ãƒ³æ›´æ–°ã‚’ç„¡åŠ¹åŒ– */
            overscroll-behavior: none;
        }
        /* Canvasã®ã‚¹ã‚¿ã‚¤ãƒ« */
        canvas {
            display: block;
            margin: 0 auto;
            background-color: #fff;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border-radius: 12px;
            cursor: default;
        }
        /* å®Ÿéš›ã®å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ç”»é¢å¤–ã«éš ã™ */
        #hidden-input {
            position: absolute;
            left: -9999px;
            top: -9999px;
            opacity: 0; /* é€æ˜ã«ã™ã‚‹ */
            pointer-events: none; /* ã‚¤ãƒ™ãƒ³ãƒˆã‚’å—ã‘ä»˜ã‘ãªã„ */
        }
        /* ãƒœã‚¿ãƒ³ã®æœ€å°å¹…ã‚’è¨­å®š */
        .control-button {
            min-width: 120px;
        }
        /* Tailwind CSSã‚¯ãƒ©ã‚¹ã¯HTMLå†…ã§ç›´æ¥ä½¿ç”¨ */
    </style>
</head>
<body class="bg-gradient-to-br from-teal-100 to-cyan-200 flex flex-col justify-center items-center min-h-screen p-4">

    <div class="w-full max-w-2xl mb-4 text-center">
        <h1 class="text-2xl md:text-3xl font-bold text-gray-800 mb-4">ç®—æ•°ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚° Canvasç‰ˆ</h1>
         <div id="stats-area" class="text-lg font-semibold text-gray-700 mb-2 h-6">
             </div>
    </div>

    <canvas id="mathCanvas" width="600" height="400">
        ãŠä½¿ã„ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯Canvasã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“ã€‚å¤ã„ãƒ–ãƒ©ã‚¦ã‚¶ã‚’ãŠä½¿ã„ã®å ´åˆã€è¡¨ç¤ºã•ã‚Œãªã„ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚
    </canvas>
    <input type="text" id="hidden-input" autocomplete="off">

    <div id="controls" class="mt-4 flex flex-wrap justify-center gap-3">
        <div id="settings-controls" class="flex flex-wrap justify-center items-center gap-3">
            <label for="num-questions" class="text-gray-700 font-medium">å•é¡Œæ•°:</label>
            <select id="num-questions" class="rounded-lg border border-gray-300 px-3 py-1 focus:outline-none focus:ring-2 focus:ring-teal-400">
                <option value="5">5å•</option>
                <option value="10" selected>10å•</option>
                <option value="15">15å•</option>
                <option value="20">20å•</option>
            </select>
            <button id="start-button" class="control-button bg-teal-500 hover:bg-teal-600 text-white font-bold py-2 px-4 rounded-lg transition shadow">ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
        </div>
        <div id="training-controls" class="hidden flex flex-wrap justify-center gap-3">
             <button id="submit-button" class="control-button bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition shadow">ã“ãŸãˆåˆã‚ã›</button>
             <button id="next-button" class="control-button bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition shadow hidden">ã¤ãã®å•é¡Œã¸</button>
        </div>
        <div id="end-controls" class="hidden flex flex-wrap justify-center gap-3">
            <button id="restart-button" class="control-button bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-lg transition shadow">ã‚‚ã†ä¸€åº¦</button>
            <button id="review-button" class="control-button bg-orange-500 hover:bg-orange-600 text-white font-bold py-2 px-4 rounded-lg transition shadow">é–“é•ã„ã‚’ç¢ºèª</button>
         </div>
         <div id="review-controls" class="hidden flex flex-wrap justify-center gap-3">
             <button id="back-to-start-button" class="control-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg transition shadow">æœ€åˆã®ç”»é¢ã¸</button>
             </div>
    </div>

    <script>
        // --- ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ãƒ»å®šæ•° ---
        const canvas = document.getElementById('mathCanvas');
        const ctx = canvas.getContext('2d');
        const hiddenInput = document.getElementById('hidden-input');
        const statsArea = document.getElementById('stats-area'); // æ­£ç­”ç‡è¡¨ç¤ºç”¨

        // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«è¦ç´ ã®å–å¾— (å¤‰æ›´ãªã—)
        const settingsControls = document.getElementById('settings-controls');
        const trainingControls = document.getElementById('training-controls');
        const endControls = document.getElementById('end-controls');
        const reviewControls = document.getElementById('review-controls');
        const numQuestionsSelect = document.getElementById('num-questions');
        const startButton = document.getElementById('start-button');
        const submitButton = document.getElementById('submit-button');
        const nextButton = document.getElementById('next-button');
        const restartButton = document.getElementById('restart-button');
        const reviewButton = document.getElementById('review-button');
        const backToStartButton = document.getElementById('back-to-start-button');

        // ã‚²ãƒ¼ãƒ ã®çŠ¶æ…‹å¤‰æ•° (å¤‰æ›´ãªã—)
        let gameState = 'settings';
        let currentQuestionIndex = 0;
        let score = 0;
        let totalQuestions = 10;
        let questions = [];
        let attemptedQuestions = [];
        let currentAnswer = '';
        let feedback = { message: '', color: 'black' };
        let mistakes = [];
        let reviewScrollOffset = 0;

        // åŠ¹æœéŸ³é–¢é€£ (å¤‰æ›´ãªã—)
        let synth;
        let isAudioContextStarted = false;

        // ãŠç¥ã„æ¼”å‡ºé–¢é€£
        let confettiParticles = []; // ç´™å¹é›ªã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«é…åˆ—
        let isCelebrating = false; // ãŠç¥ã„æ¼”å‡ºä¸­ã‹ã©ã†ã‹ã®ãƒ•ãƒ©ã‚°
        let celebrationPlayed = false; // ãŠç¥ã„åŠ¹æœéŸ³ãŒå†ç”Ÿæ¸ˆã¿ã‹ã©ã†ã‹ã®ãƒ•ãƒ©ã‚°

        // Canvasæç”»é–¢é€£ã®å®šæ•° (å¤‰æ›´ãªã—)
        const CANVAS_WIDTH = canvas.width;
        const CANVAS_HEIGHT = canvas.height;
        const PROGRESS_Y = 55;
        const QUESTION_Y = 130;
        const INPUT_BOX_Y = 190;
        const INPUT_BOX_HEIGHT = 40;
        const FEEDBACK_Y = 290;
        const SCORE_Y = 40;


        // --- è¨ˆç®—é–¢é€£ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•° (å¤‰æ›´ãªã—) ---
        function getRandomInt(min, max) { min = Math.ceil(min); max = Math.floor(max); return Math.floor(Math.random() * (max - min + 1)) + min; }
        function getRandomNonZeroInt(min, max) { let num; do { num = getRandomInt(min, max); } while (num === 0); return num; }
        function gcd(a, b) { a = Math.abs(a); b = Math.abs(b); return b === 0 ? a : gcd(b, a % b); }
        function lcm(a, b) { if (a === 0 || b === 0) return 0; return Math.abs(a * b) / gcd(a, b); }
        function simplifyFractionObj(frac) { if (frac.d === 0) throw new Error("Denominator cannot be zero."); if (frac.n === 0) return { n: 0, d: 1 }; const commonDivisor = gcd(frac.n, frac.d); let simplifiedN = frac.n / commonDivisor; let simplifiedD = frac.d / commonDivisor; if (simplifiedD < 0) { simplifiedN = -simplifiedN; simplifiedD = -simplifiedD; } return { n: simplifiedN, d: simplifiedD }; }
        function fractionObjToString(frac, useAnd = true) { if (frac.d === 1 || frac.n === 0) { return frac.n.toString(); } if (Math.abs(frac.n) >= frac.d) { const wholePart = Math.trunc(frac.n / frac.d); const remainderN = Math.abs(frac.n % frac.d); if (remainderN === 0) return wholePart.toString(); const remainderFrac = simplifyFractionObj({ n: remainderN, d: frac.d }); const separator = useAnd ? "ã¨" : " "; return `${wholePart}${separator}${remainderFrac.n}/${remainderFrac.d}`; } return `${frac.n}/${frac.d}`; }
        function parseAnswerInput(inputStr) { inputStr = inputStr.trim().replace(/ï¼/g, '/').replace(/ /g, ''); const mixedMatch = inputStr.match(/^([+-]?\d+)ã¨(\d+)\/(\d+)$/); if (mixedMatch) { const whole = parseInt(mixedMatch[1], 10); const num = parseInt(mixedMatch[2], 10); const den = parseInt(mixedMatch[3], 10); if (isNaN(whole) || isNaN(num) || isNaN(den) || den === 0 || num < 0 || den < 0) return null; const totalNum = whole >= 0 ? (whole * den + num) : (whole * den - num); return simplifyFractionObj({ n: totalNum, d: den }); } const fractionMatch = inputStr.match(/^([+-]?\d+)\/(\d+)$/); if (fractionMatch) { const num = parseInt(fractionMatch[1], 10); const den = parseInt(fractionMatch[2], 10); if (isNaN(num) || isNaN(den) || den === 0 || den < 0) return null; return simplifyFractionObj({ n: num, d: den }); } const numberMatch = inputStr.match(/^[+-]?(\d+(\.\d*)?|\.\d+)$/); if (numberMatch) { const num = parseFloat(inputStr); return isNaN(num) ? null : num; } return null; }
        function formatAnswer(answer) { if (typeof answer === 'number') { const factor = Math.pow(10, DECIMAL_PLACES + 2); return (Math.round(answer * factor) / factor).toString(); } else if (typeof answer === 'object' && answer !== null && typeof answer.n === 'number') { return fractionObjToString(answer); } return ''; }

        // --- å•é¡Œç”Ÿæˆé–¢æ•° (å¤‰æ›´ãªã—) ---
        const MAX_NUM_SIMPLE = 10; const MAX_NUM_ADVANCED = 15; const MAX_DENOMINATOR = 12; const DECIMAL_PLACES = 2;
        function generateRandomFraction(allowImproper = true, allowNegative = false) { let n, d; d = getRandomInt(2, MAX_DENOMINATOR); if (allowImproper) { n = getRandomInt(1, MAX_NUM_ADVANCED); } else { n = getRandomInt(1, d - 1); } if (allowNegative && Math.random() < 0.3) { n = -n; } return simplifyFractionObj({ n, d });}
        function generateFractionAddition() { const f1 = generateRandomFraction(true, false); const f2 = generateRandomFraction(true, false); const commonDenominator = lcm(f1.d, f2.d); const n1 = f1.n * (commonDenominator / f1.d); const n2 = f2.n * (commonDenominator / f2.d); const answer = simplifyFractionObj({ n: n1 + n2, d: commonDenominator }); const question = `${fractionObjToString(f1)} + ${fractionObjToString(f2)} = ?`; return { question, answer, type: 'fraction' }; }
        function generateFractionSubtraction() { let f1, f2, answer; do { f1 = generateRandomFraction(true, false); f2 = generateRandomFraction(true, false); const commonDenominator = lcm(f1.d, f2.d); const n1 = f1.n * (commonDenominator / f1.d); const n2 = f2.n * (commonDenominator / f2.d); if (n1 < n2) [f1, f2] = [f2, f1]; const new_n1 = f1.n * (lcm(f1.d, f2.d) / f1.d); const new_n2 = f2.n * (lcm(f1.d, f2.d) / f2.d); answer = simplifyFractionObj({ n: new_n1 - new_n2, d: lcm(f1.d, f2.d) }); } while (answer.n < 0 && Math.random() < 0.7); const question = `${fractionObjToString(f1)} - ${fractionObjToString(f2)} = ?`; return { question, answer, type: 'fraction' }; }
        function generateFractionMultiplication() { const f1 = generateRandomFraction(false, false); const f2 = generateRandomFraction(false, false); const answer = simplifyFractionObj({ n: f1.n * f2.n, d: f1.d * f2.d }); const question = `${fractionObjToString(f1)} Ã— ${fractionObjToString(f2)} = ?`; return { question, answer, type: 'fraction' }; }
        function generateFractionDivision() { const f1 = generateRandomFraction(false, false); let f2; do {f2 = generateRandomFraction(false, false);} while (f2.n === 0); const answer = simplifyFractionObj({ n: f1.n * f2.d, d: f1.d * f2.n }); const question = `${fractionObjToString(f1)} Ã· ${fractionObjToString(f2)} = ?`; return { question, answer, type: 'fraction' }; }
        function generateRandomDecimal() { const factor = Math.pow(10, getRandomInt(1, DECIMAL_PLACES)); const num = getRandomInt(1, MAX_NUM_SIMPLE * factor); return num / factor; }
        function generateDecimalAddition() { const d1 = generateRandomDecimal(); const d2 = generateRandomDecimal(); const factor = Math.pow(10, DECIMAL_PLACES); const answer = (Math.round(d1 * factor) + Math.round(d2 * factor)) / factor; const question = `${formatAnswer(d1)} + ${formatAnswer(d2)} = ?`; return { question, answer: answer, type: 'decimal' }; }
        function generateDecimalSubtraction() { let d1, d2, answer; const factor = Math.pow(10, DECIMAL_PLACES); do { d1 = generateRandomDecimal(); d2 = generateRandomDecimal(); if (d1 < d2) [d1, d2] = [d2, d1]; answer = (Math.round(d1 * factor) - Math.round(d2 * factor)) / factor; } while (answer < 0 && Math.random() < 0.7); const question = `${formatAnswer(d1)} - ${formatAnswer(d2)} = ?`; return { question, answer: answer, type: 'decimal' }; }
        function generateDecimalMultiplication() { const d1 = generateRandomDecimal(); const d2 = getRandomInt(2, 9); const factor = Math.pow(10, DECIMAL_PLACES * 2); const answer = (Math.round(d1 * factor) * d2) / factor; const question = `${formatAnswer(d1)} Ã— ${d2} = ?`; return { question, answer: answer, type: 'decimal' }; }
        function generateDecimalDivision() { const divisor = getRandomInt(2, 9); const quotient = generateRandomDecimal(); const factor = Math.pow(10, DECIMAL_PLACES * 2); let dividend = (Math.round(quotient * factor) * divisor) / factor; if (Math.abs(dividend) < 0.01) return generateDecimalDivision(); const displayDividend = formatAnswer(dividend); const question = `${displayDividend} Ã· ${divisor} = ?`; const answer = quotient; return { question, answer: answer, type: 'decimal' }; }
        function generateQuestions(numQs) { questions = []; const questionTypes = [ generateFractionAddition, generateFractionSubtraction, generateFractionMultiplication, generateFractionDivision, generateDecimalAddition, generateDecimalSubtraction, generateDecimalMultiplication, generateDecimalDivision ]; for (let i = 0; i < numQs; i++) { const randomTypeIndex = Math.floor(Math.random() * questionTypes.length); try { questions.push(questionTypes[randomTypeIndex]()); } catch (error) { console.error("Error generating question:", error); i--; } } }

        // --- Canvasæç”»é–¢é€£é–¢æ•° ---

        /** Canvasã‚’ã‚¯ãƒªã‚¢ */
        function clearCanvas() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        }

        /** ãƒ†ã‚­ã‚¹ãƒˆã‚’æç”» */
        function drawText(text, x, y, font = '18px Inter', color = 'black', align = 'center') {
            ctx.font = font;
            ctx.fillStyle = color;
            ctx.textAlign = align;
            ctx.fillText(text, x, y);
        }

        /** ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ã‚’æç”» */
        function drawProgressBar() { // (å¤‰æ›´ãªã—)
            const barWidth = CANVAS_WIDTH * 0.6;
            const barHeight = 10;
            const barX = (CANVAS_WIDTH - barWidth) / 2;
            const progress = totalQuestions > 0 ? (currentQuestionIndex + (gameState === 'feedback' || gameState === 'finished' ? 1 : 0)) / totalQuestions : 0;
            ctx.fillStyle = '#e0e0e0';
            ctx.fillRect(barX, PROGRESS_Y, barWidth, barHeight);
            ctx.fillStyle = '#4ade80';
            ctx.fillRect(barX, PROGRESS_Y, barWidth * progress, barHeight);
             if (totalQuestions > 0 && gameState !== 'settings' && gameState !== 'finished' && gameState !== 'review') {
                  drawText(`${currentQuestionIndex + 1} / ${totalQuestions} å•ç›®`, CANVAS_WIDTH / 2, PROGRESS_Y + 25, '14px Inter', 'grey');
             }
        }

        /** è¨­å®šç”»é¢ã‚’æç”» */
        function drawSettingsScreen() { // (å¤‰æ›´ãªã—)
            drawText('è¨­å®š', CANVAS_WIDTH / 2, 150, '32px "M PLUS Rounded 1c"', 'black');
            drawText('å•é¡Œæ•°ã‚’é¸æŠã—ã¦ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„', CANVAS_WIDTH / 2, 200, '18px Inter', 'grey');
        }

        /** ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ç”»é¢ã‚’æç”» */
        function drawTrainingScreen() { // (å¤‰æ›´ãªã—)
            drawProgressBar();
            const currentQ = questions[currentQuestionIndex];
            if (!currentQ) return;
            drawText(currentQ.question, CANVAS_WIDTH / 2, QUESTION_Y, 'bold 28px "M PLUS Rounded 1c"', '#333');
            const inputBoxWidth = CANVAS_WIDTH * 0.7;
            const inputBoxX = (CANVAS_WIDTH - inputBoxWidth) / 2;
            ctx.strokeStyle = '#a0aec0';
            ctx.lineWidth = 1;
            ctx.strokeRect(inputBoxX, INPUT_BOX_Y, inputBoxWidth, INPUT_BOX_HEIGHT);
            drawText('ç­”ãˆ:', inputBoxX - 10, INPUT_BOX_Y + INPUT_BOX_HEIGHT / 2 + 7, '18px Inter', 'black', 'right');
            drawText(currentAnswer, inputBoxX + 10, INPUT_BOX_Y + INPUT_BOX_HEIGHT / 2 + 7, '20px Inter', 'black', 'left');
            if (document.activeElement === hiddenInput && Math.floor(Date.now() / 500) % 2 === 0) {
                ctx.save();
                ctx.font = '20px Inter';
                const textWidth = ctx.measureText(currentAnswer).width;
                const cursorX = inputBoxX + 10 + textWidth + 2;
                ctx.fillStyle = 'black';
                ctx.fillRect(cursorX, INPUT_BOX_Y + 5, 2, INPUT_BOX_HEIGHT - 10);
                ctx.restore();
            }
             drawText('â€» åˆ†æ•°: 3/4, å¸¯åˆ†æ•°: 1ã¨1/2, å°æ•°: 0.5', CANVAS_WIDTH / 2, INPUT_BOX_Y + INPUT_BOX_HEIGHT + 25, '14px Inter', 'grey');
        }

        /** ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ç”»é¢ã‚’æç”» */
        function drawFeedbackScreen() { // (å¤‰æ›´ãªã—)
            drawTrainingScreen();
            drawText(feedback.message, CANVAS_WIDTH / 2, FEEDBACK_Y, 'bold 20px Inter', feedback.color);
        }

        // --- ãŠç¥ã„æ¼”å‡ºï¼ˆç´™å¹é›ªï¼‰é–¢é€£ ---
        const confettiColors = ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4caf50', '#8bc34a', '#cddc39', '#ffeb3b', '#ffc107', '#ff9800', '#ff5722'];

        /** ç´™å¹é›ªãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ç”Ÿæˆ */
        function createConfetti() {
            confettiParticles = []; // é…åˆ—ã‚’ãƒªã‚»ãƒƒãƒˆ
            const numberOfParticles = 100; // ç”Ÿæˆã™ã‚‹æ•°
            for (let i = 0; i < numberOfParticles; i++) {
                confettiParticles.push({
                    x: Math.random() * CANVAS_WIDTH, // é–‹å§‹Xåº§æ¨™ (ãƒ©ãƒ³ãƒ€ãƒ )
                    y: -Math.random() * CANVAS_HEIGHT * 0.5, // é–‹å§‹Yåº§æ¨™ (ç”»é¢ä¸Šéƒ¨å¤–ã‹ã‚‰)
                    size: Math.random() * 5 + 3, // ã‚µã‚¤ã‚º (3ã€œ8)
                    color: confettiColors[Math.floor(Math.random() * confettiColors.length)], // è‰²
                    speedX: Math.random() * 6 - 3, // æ¨ªæ–¹å‘ã®é€Ÿåº¦ (-3ã€œ3)
                    speedY: Math.random() * 3 + 2, // ç¸¦æ–¹å‘ã®åˆé€Ÿåº¦ (2ã€œ5)
                    angle: Math.random() * Math.PI * 2, // å›è»¢è§’åº¦
                    angularSpeed: Math.random() * 0.1 - 0.05 // å›è»¢é€Ÿåº¦
                });
            }
        }

        /** ç´™å¹é›ªã®çŠ¶æ…‹ã‚’æ›´æ–° */
        function updateConfetti() {
            const gravity = 0.1; // é‡åŠ›
            confettiParticles.forEach((p, index) => {
                p.speedY += gravity; // é‡åŠ›ã§åŠ é€Ÿ
                p.x += p.speedX;
                p.y += p.speedY;
                p.angle += p.angularSpeed;

                // ç”»é¢å¤–ã«å‡ºãŸã‚‰å‰Šé™¤ (é…åˆ—ã®å¾Œã‚ã‹ã‚‰å‰Šé™¤ã™ã‚‹ã®ãŒå®‰å…¨)
                // ãŸã ã—ã€é »ç¹ãªå‰Šé™¤ã¯ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã«å½±éŸ¿ã™ã‚‹å¯èƒ½æ€§ã‚ã‚Š
                // ã“ã“ã§ã¯å˜ç´”åŒ–ã®ãŸã‚ã€ç”»é¢ä¸‹ã«å®Œå…¨ã«å‡ºãŸã‚‰å‰Šé™¤
                if (p.y > CANVAS_HEIGHT + p.size) {
                    // confettiParticles.splice(index, 1); // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è€ƒæ…®ã—ã€ä»Šå›ã¯å‰Šé™¤ã—ãªã„
                }
            });
            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãŒå…¨ã¦ç”»é¢å¤–ã«å‡ºãŸã‚‰ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åœæ­¢ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹ï¼ˆä»»æ„ï¼‰
             if (confettiParticles.every(p => p.y > CANVAS_HEIGHT + p.size)) {
                 // isCelebrating = false; // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æ­¢ã‚ã‚‹å ´åˆ
             }
        }

        /** ç´™å¹é›ªã‚’æç”» */
        function drawConfetti() {
            confettiParticles.forEach(p => {
                ctx.save();
                ctx.fillStyle = p.color;
                ctx.translate(p.x + p.size / 2, p.y + p.size / 2); // å›è»¢ã®ä¸­å¿ƒã‚’ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ä¸­å¿ƒã«
                ctx.rotate(p.angle);
                ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size); // ä¸­å¿ƒåŸºæº–ã§æç”»
                ctx.restore();
            });
        }
        // --- ç´™å¹é›ªã“ã“ã¾ã§ ---


         /** çµ‚äº†ç”»é¢ã‚’æç”» */
        function drawFinishedScreen() {
            const finalScoreText = `çµ‚äº†ï¼ ${totalQuestions}å•ä¸­ ${score}å•æ­£è§£ï¼`;
            const accuracy = totalQuestions > 0 ? ((score / totalQuestions) * 100) : 0; // ç™¾åˆ†ç‡
            const accuracyText = `æœ€çµ‚æ­£ç­”ç‡: ${accuracy.toFixed(1)}%`;

            // --- ãŠç¥ã„æ¼”å‡ºã®é–‹å§‹åˆ¤å®š ---
            if (accuracy >= 80 && !celebrationPlayed) {
                isCelebrating = true; // ãŠç¥ã„æ¼”å‡ºãƒ•ãƒ©ã‚°ON
                celebrationPlayed = true; // åŠ¹æœéŸ³å†ç”Ÿæ¸ˆã¿ãƒ•ãƒ©ã‚°ON
                createConfetti(); // ç´™å¹é›ªç”Ÿæˆ

                // ãŠç¥ã„åŠ¹æœéŸ³
                if (synth && isAudioContextStarted) {
                    try {
                         // ç°¡å˜ãªä¸Šæ˜‡éŸ³éš
                         synth.triggerAttackRelease("C5", "8n", Tone.now());
                         synth.triggerAttackRelease("E5", "8n", Tone.now() + 0.15);
                         synth.triggerAttackRelease("G5", "8n", Tone.now() + 0.3);
                         synth.triggerAttackRelease("C6", "4n", Tone.now() + 0.45);
                    } catch(e) {
                        console.error("Error playing celebration sound:", e);
                    }
                }
            }
            // --- ãŠç¥ã„æ¼”å‡ºã“ã“ã¾ã§ ---

            // ç´™å¹é›ªã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®æ›´æ–°ã¨æç”» (ãŠç¥ã„ä¸­ã®ã¿)
            if (isCelebrating) {
                updateConfetti();
                drawConfetti();
            }

            // ãƒ†ã‚­ã‚¹ãƒˆæç”» (ç´™å¹é›ªã®ä¸Šã«æç”»ã•ã‚Œã‚‹ã‚ˆã†ã«å¾Œã‹ã‚‰æç”»)
            drawText('ãŠç–²ã‚Œæ§˜ã§ã—ãŸï¼', CANVAS_WIDTH / 2, 120, '32px "M PLUS Rounded 1c"', 'black');
            drawText(finalScoreText, CANVAS_WIDTH / 2, 180, '24px Inter', '#4a5568');
            drawText(accuracyText, CANVAS_WIDTH / 2, 220, '24px Inter', '#4a5568');

            if (mistakes.length > 0) {
                 drawText(`(${mistakes.length}å•ã®é–“é•ã„ãŒã‚ã‚Šã¾ã—ãŸ)`, CANVAS_WIDTH / 2, 260, '16px Inter', 'grey');
            } else {
                 drawText('å…¨å•æ­£è§£ã§ã™ï¼ç´ æ™´ã‚‰ã—ã„ï¼ ğŸ‰', CANVAS_WIDTH / 2, 260, '18px Inter', 'green');
                 // å…¨å•æ­£è§£ã§ã‚‚ãŠç¥ã„æ¼”å‡ºã‚’é–‹å§‹ï¼ˆ80%ä»¥ä¸Šãªã®ã§å¿…ãštrueã«ãªã‚‹ã¯ãšã ãŒå¿µã®ãŸã‚ï¼‰
                 if (!celebrationPlayed) {
                     isCelebrating = true;
                     celebrationPlayed = true;
                     createConfetti();
                     // åŠ¹æœéŸ³ã‚‚ï¼ˆé‡è¤‡å†ç”Ÿé˜²æ­¢ã¯ celebrationPlayed ãƒ•ãƒ©ã‚°ã§ç®¡ç†ï¼‰
                     if (synth && isAudioContextStarted) {
                        try {
                             synth.triggerAttackRelease("C5", "8n", Tone.now());
                             synth.triggerAttackRelease("E5", "8n", Tone.now() + 0.15);
                             synth.triggerAttackRelease("G5", "8n", Tone.now() + 0.3);
                             synth.triggerAttackRelease("C6", "4n", Tone.now() + 0.45);
                        } catch(e) { console.error("Error playing sound:", e); }
                     }
                 }
            }

            // ãŠç¥ã„æ¼”å‡ºä¸­ã¯ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ç¶™ç¶š
            if (isCelebrating) {
                requestAnimationFrame(draw);
            }
        }

        /** ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”»é¢ã‚’æç”» */
        function drawReviewScreen() { // (å¤‰æ›´ãªã—)
            drawText('é–“é•ã„ã®ç¢ºèª', CANVAS_WIDTH / 2, 40, '24px "M PLUS Rounded 1c"', 'black');
            if (mistakes.length === 0) {
                drawText('é–“é•ãˆãŸå•é¡Œã¯ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚', CANVAS_WIDTH / 2, 150, '18px Inter', 'green');
                return;
            }
            const itemHeight = 85; const startY = 80; const contentWidth = CANVAS_WIDTH * 0.9; const startX = (CANVAS_WIDTH - contentWidth) / 2;
             ctx.save(); ctx.beginPath(); ctx.rect(0, startY - 10, CANVAS_WIDTH, CANVAS_HEIGHT - startY - 20); ctx.clip();
             const drawStartY = startY - reviewScrollOffset;
            mistakes.forEach((mistake, index) => {
                const yPos = drawStartY + index * itemHeight;
                 if (yPos + itemHeight < startY - 10 || yPos > CANVAS_HEIGHT - 10) { return; }
                ctx.fillStyle = index % 2 === 0 ? '#f7fafc' : '#edf2f7';
                ctx.fillRect(startX, yPos, contentWidth, itemHeight - 5);
                drawText(`å•é¡Œ ${mistake.index + 1}: ${mistake.questionObj.question}`, startX + 10, yPos + 20, '16px "M PLUS Rounded 1c"', '#2d3748', 'left');
                drawText(`ã‚ãªãŸã®ç­”ãˆ: ${mistake.userAnswerRaw}`, startX + 15, yPos + 45, '16px Inter', '#e53e3e', 'left');
                drawText(`æ­£è§£: ${formatAnswer(mistake.correctAnswer)}`, startX + 15, yPos + 70, '16px Inter', '#38a169', 'left');
            });
            ctx.restore();
            const totalContentHeight = mistakes.length * itemHeight; const visibleHeight = CANVAS_HEIGHT - startY - 20;
            if (totalContentHeight > visibleHeight) {
                const scrollBarHeight = Math.max(20, visibleHeight * (visibleHeight / totalContentHeight));
                const scrollBarY = (startY - 10) + (reviewScrollOffset / (totalContentHeight - visibleHeight)) * (visibleHeight - scrollBarHeight);
                const scrollBarX = CANVAS_WIDTH - 15;
                 ctx.fillStyle = '#a0aec0'; ctx.fillRect(scrollBarX, scrollBarY, 8, scrollBarHeight);
            }
        }

        /** ãƒ¡ã‚¤ãƒ³ã®æç”»é–¢æ•° */
        function draw() {
            clearCanvas();
            updateStatsDisplay();

            switch (gameState) {
                case 'settings': drawSettingsScreen(); break;
                case 'training': drawTrainingScreen(); break;
                case 'feedback': drawFeedbackScreen(); break;
                case 'finished': drawFinishedScreen(); break; // å†…éƒ¨ã§ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç®¡ç†ã™ã‚‹å ´åˆã‚ã‚Š
                case 'review': drawReviewScreen(); break;
            }

            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—ã®ç¶™ç¶šåˆ¤å®š
            // ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ä¸­(ã‚«ãƒ¼ã‚½ãƒ«ç‚¹æ»…) ã¾ãŸã¯ ãŠç¥ã„ä¸­(ç´™å¹é›ª)
             if (gameState === 'training' || document.activeElement === hiddenInput || isCelebrating) {
                 requestAnimationFrame(draw);
             }
        }

        // --- ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯é–¢é€£é–¢æ•° ---

        /** çµ±è¨ˆæƒ…å ±è¡¨ç¤ºã‚’æ›´æ–° */
        function updateStatsDisplay() { // (å¤‰æ›´ãªã—)
             const attemptedCount = attemptedQuestions.length;
             const correctCount = attemptedQuestions.filter(q => q.isCorrect).length;
             const accuracy = attemptedCount > 0 ? ((correctCount / attemptedCount) * 100).toFixed(1) : '---';
             statsArea.textContent = `ç´¯è¨ˆæ­£ç­”ç‡: ${accuracy}% (${correctCount}/${attemptedCount}å•)`;
        }

        /** æ“ä½œãƒœã‚¿ãƒ³ã®è¡¨ç¤ºåˆ‡æ›¿ */
        function switchControls(state) { // (å¤‰æ›´ãªã—)
             settingsControls.classList.add('hidden'); trainingControls.classList.add('hidden'); endControls.classList.add('hidden'); reviewControls.classList.add('hidden');
             switch(state) {
                 case 'settings': settingsControls.classList.remove('hidden'); break;
                 case 'training': trainingControls.classList.remove('hidden'); submitButton.classList.remove('hidden'); nextButton.classList.add('hidden'); break;
                 case 'feedback': trainingControls.classList.remove('hidden'); submitButton.classList.add('hidden'); nextButton.classList.remove('hidden'); break;
                 case 'finished': endControls.classList.remove('hidden'); break;
                 case 'review': reviewControls.classList.remove('hidden'); break;
             }
        }

        /** ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’é–‹å§‹ */
        async function startAudioContext() { // (å¤‰æ›´ãªã—)
            if (!isAudioContextStarted && Tone.context.state !== 'running') {
                try {
                    await Tone.start(); console.log('Audio context started successfully.'); isAudioContextStarted = true;
                     if (!synth) { synth = new Tone.Synth().toDestination(); }
                } catch (e) { console.error("Could not start audio context:", e); isAudioContextStarted = false; }
            }
             if (isAudioContextStarted && !synth) { synth = new Tone.Synth().toDestination(); }
        }

        /** ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã‚’é–‹å§‹ */
        async function startTraining() { // (å¤‰æ›´ãªã—)
            await startAudioContext();
            totalQuestions = parseInt(numQuestionsSelect.value, 10);
            currentQuestionIndex = 0; score = 0; attemptedQuestions = []; mistakes = []; reviewScrollOffset = 0;
            // ãŠç¥ã„é–¢é€£ãƒ•ãƒ©ã‚°ã‚‚ãƒªã‚»ãƒƒãƒˆ
            isCelebrating = false;
            celebrationPlayed = false;
            confettiParticles = []; // ç´™å¹é›ªã‚‚ã‚¯ãƒªã‚¢
            generateQuestions(totalQuestions);
            gameState = 'training'; currentAnswer = ''; hiddenInput.value = '';
            switchControls('training'); hiddenInput.focus();
            draw(); requestAnimationFrame(draw);
        }

        /** ç­”ãˆã‚’ãƒã‚§ãƒƒã‚¯ */
        function checkAnswer() {
            if (gameState !== 'training') return;

            const userAnswerRaw = hiddenInput.value; currentAnswer = userAnswerRaw;
            const parsedUserAnswer = parseAnswerInput(userAnswerRaw);
            const currentQ = questions[currentQuestionIndex]; const correctAnswer = currentQ.answer;
            let isCorrect = false; const correctAnswerStr = formatAnswer(correctAnswer);

            if (parsedUserAnswer === null) {
                feedback = { message: 'ä¸æ­£ãªå…¥åŠ›å½¢å¼ã§ã™', color: 'orange' }; isCorrect = false;
            } else {
                // æ­£èª¤åˆ¤å®š (å¤‰æ›´ãªã—)
                if (typeof correctAnswer === 'object' && correctAnswer !== null && typeof correctAnswer.n === 'number') {
                    if (typeof parsedUserAnswer === 'object' && parsedUserAnswer !== null && typeof parsedUserAnswer.n === 'number') { isCorrect = parsedUserAnswer.n === correctAnswer.n && parsedUserAnswer.d === correctAnswer.d; }
                    else if (typeof parsedUserAnswer === 'number') { const correctValue = correctAnswer.n / correctAnswer.d; isCorrect = Math.abs(parsedUserAnswer - correctValue) < 0.00001; }
                } else if (typeof correctAnswer === 'number') {
                     if (typeof parsedUserAnswer === 'number') { isCorrect = Math.abs(parsedUserAnswer - correctAnswer) < 0.00001; }
                     else if (typeof parsedUserAnswer === 'object' && parsedUserAnswer !== null) { const userValue = parsedUserAnswer.n / parsedUserAnswer.d; isCorrect = Math.abs(userValue - correctAnswer) < 0.00001; }
                }

                if (isCorrect) {
                    score++; feedback = { message: 'æ­£è§£ï¼ ğŸ‰', color: 'green' };
                    // æ­£è§£åŠ¹æœéŸ³ (å¤‰æ›´ãªã—)
                    if (synth && isAudioContextStarted) { try { synth.triggerAttackRelease("C5", "8n", Tone.now()); } catch(e) { console.error("Error playing sound:", e); } }
                } else {
                    feedback = { message: `æ®‹å¿µï¼ æ­£è§£ã¯ ${correctAnswerStr} ã§ã—ãŸ`, color: 'red' };
                    // â˜… ä¸æ­£è§£ã®åŠ¹æœéŸ³ã‚’è¿½åŠ  â˜…
                    if (synth && isAudioContextStarted) {
                        try {
                             synth.triggerAttackRelease("A3", "8n", Tone.now()); // ä½ã„éŸ³ 'A3'
                        } catch(e) { console.error("Error playing sound:", e); }
                    }
                }
            }

            attemptedQuestions.push({ index: currentQuestionIndex, questionObj: currentQ, userAnswerRaw: userAnswerRaw, userAnswerParsed: parsedUserAnswer, correctAnswer: correctAnswer, isCorrect: isCorrect });
            if (!isCorrect) { mistakes.push(attemptedQuestions[attemptedQuestions.length - 1]); }

            gameState = 'feedback'; switchControls('feedback'); hiddenInput.blur();
            draw();
        }

        /** æ¬¡ã®å•é¡Œã¸ */
        function nextQuestion() { // (å¤‰æ›´ãªã—)
            if (gameState !== 'feedback') return;
            currentQuestionIndex++;
            if (currentQuestionIndex < totalQuestions) {
                gameState = 'training'; currentAnswer = ''; hiddenInput.value = '';
                switchControls('training'); hiddenInput.focus(); requestAnimationFrame(draw);
            } else {
                gameState = 'finished'; switchControls('finished');
                // çµ‚äº†ç”»é¢ã«é·ç§»ã™ã‚‹éš›ã«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—ã‚’é–‹å§‹ã•ã›ã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆ
                draw(); // Draw once to trigger potential celebration start
                if (isCelebrating) requestAnimationFrame(draw); // Start animation if celebrating
            }
            // draw() ã¯ finished çŠ¶æ…‹ã§å‘¼ã°ã‚Œã‚‹ drawFinishedScreen å†…ã§ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç®¡ç†ã•ã‚Œã‚‹
        }

         /** ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ */
         function restartTraining() { // (å¤‰æ›´ãªã—)
             // ãŠç¥ã„çŠ¶æ…‹ã‚‚ãƒªã‚»ãƒƒãƒˆ
             isCelebrating = false;
             celebrationPlayed = false;
             confettiParticles = [];

             gameState = 'settings'; currentAnswer = ''; hiddenInput.value = '';
             feedback = { message: '', color: 'black' }; statsArea.textContent = '';
             switchControls('settings'); draw();
         }

         /** ãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤º */
         function showReview() { // (å¤‰æ›´ãªã—)
             if (gameState !== 'finished') return;
             isCelebrating = false; // ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”»é¢ã§ã¯ãŠç¥ã„ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åœæ­¢
             gameState = 'review'; reviewScrollOffset = 0;
             switchControls('review'); draw();
         }

         /** è¨­å®šç”»é¢ã¸æˆ»ã‚‹ */
         function backToStart() { // (å¤‰æ›´ãªã—)
             if (gameState !== 'review') return;
              restartTraining();
         }

        // --- ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š ---
        startButton.addEventListener('click', async () => { await startTraining(); }); // (å¤‰æ›´ãªã—)
        submitButton.addEventListener('click', checkAnswer); // (å¤‰æ›´ãªã—)
        nextButton.addEventListener('click', nextQuestion); // (å¤‰æ›´ãªã—)
        restartButton.addEventListener('click', restartTraining); // (å¤‰æ›´ãªã—)
        reviewButton.addEventListener('click', showReview); // (å¤‰æ›´ãªã—)
        backToStartButton.addEventListener('click', backToStart); // (å¤‰æ›´ãªã—)

        hiddenInput.addEventListener('input', (e) => { if (gameState === 'training') { currentAnswer = e.target.value; } }); // (å¤‰æ›´ãªã—)
        hiddenInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') { e.preventDefault(); if (gameState === 'training') { checkAnswer(); } else if (gameState === 'feedback') { nextQuestion(); } } }); // (å¤‰æ›´ãªã—)
        canvas.addEventListener('click', async (e) => { await startAudioContext(); if (gameState === 'training') { const rect = canvas.getBoundingClientRect(); const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height; const canvasX = (e.clientX - rect.left) * scaleX; const canvasY = (e.clientY - rect.top) * scaleY; const inputBoxWidth = CANVAS_WIDTH * 0.7; const inputBoxX = (CANVAS_WIDTH - inputBoxWidth) / 2; if (canvasX >= inputBoxX && canvasX <= inputBoxX + inputBoxWidth && canvasY >= INPUT_BOX_Y && canvasY <= INPUT_BOX_Y + INPUT_BOX_HEIGHT) { hiddenInput.focus(); requestAnimationFrame(draw); } } }); // (å¤‰æ›´ãªã—)
        canvas.addEventListener('wheel', (e) => { if (gameState === 'review' && mistakes.length > 0) { e.preventDefault(); const itemHeight = 85; const totalContentHeight = mistakes.length * itemHeight; const visibleHeight = CANVAS_HEIGHT - 80 - 20; if (totalContentHeight > visibleHeight) { reviewScrollOffset += e.deltaY * 0.5; reviewScrollOffset = Math.max(0, reviewScrollOffset); reviewScrollOffset = Math.min(reviewScrollOffset, totalContentHeight - visibleHeight + 20); draw(); } } }, { passive: false }); // (å¤‰æ›´ãªã—)


        // --- ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ– ---
        function init() { // (å¤‰æ›´ãªã—)
            gameState = 'settings'; switchControls('settings'); draw();
            if (!synth) { try { synth = new Tone.Synth().toDestination(); } catch(e) { console.error("Failed to initialize synth on load:", e); } }
        }

        // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
        init();

    </script>

</body>
</html>
